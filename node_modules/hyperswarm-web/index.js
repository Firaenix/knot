const { EventEmitter } = require('events')
const webRTCSwarm = require('@geut/discovery-swarm-webrtc')
const HyperswarmClient = require('hyperswarm-proxy-ws/client')

const DEFAULT_WEBRTC_BOOTSTRAP = ['https://geut-webrtc-signal.herokuapp.com/']
const DEFAULT_PROXY_SERVER = 'wss://hyperswarm.mauve.moe'

module.exports = function swarm (opts) {
  return new HyperswarmWeb(opts)
}

class HyperswarmWeb extends EventEmitter {
  constructor (opts = {}) {
    super()
    const {
      maxPeers,
      webrtcBootstrap,
      wsProxy,
      simplePeer,
      wsReconnectDelay
    } = opts

    this.webrtcOpts = {
      maxPeers,
      simplePeer,
      bootstrap: webrtcBootstrap || DEFAULT_WEBRTC_BOOTSTRAP,
    }
    this.wsOpts = {
      maxPeers,
      proxy: wsProxy || DEFAULT_PROXY_SERVER
    }

    if (wsReconnectDelay) {
      this.wsOpts.reconnectDelay = wsReconnectDelay
    }

    this.isListening = false
    this.destroyed = false
  }

  _handleWS (connection, info) {
    this.emit('connection', connection, info)
  }

  _handleWebRTC (connection, discoveryInfo) {
  	const info = new WebRTCInfo(discoveryInfo)

    this.emit('connection', connection, info)
  }

  address () {
    // TODO: What could possibly go here?!?!?!
    return { port: 0, family: 'IPv4', address: '127.0.0.1' }
  }

  listen (port, cb) {
    if (this.isListening) return setTimeout(cb, 0)

    this.isListening = true

    this.webrtc = webRTCSwarm(this.webrtcOpts)
    this.ws = new HyperswarmClient(this.wsOpts)

    this.ws.on('connection', (connection, info) => this._handleWS(connection, info))
    this.webrtc.on('connection', (connection, info) => this._handleWebRTC(connection, info))
  }

  join (key, opts) {
    this.listen()

    this.webrtc.join(key)
    this.ws.join(key, opts)
  }

  leave (key) {
    this.listen()

    this.webrtc.leave(key)
    this.ws.leave(key)
  }

  connect (peer, cb) {
    this.listen()

    this.ws.connect(peer, cb)
  }

  connectivity (cb) {
    this.listen(() => {
      cb(null, {
        bound: true,
        bootstrapped: true,
        holepunched: true
      })
    })
  }

  // No clue how to implement this, it's undocumented
  flush (cb) {
    process.nextTick(cb)
  }

  // Always return that we're looking up and not announcing
  status () {
    return {
      lookup: true,
      announce: false
    }
  }

  destroy (cb) {
    this.destroyed = true
    this.ws.destroy(() => {
      this.webrtc.close().then(cb, cb)
    })
  }
}

class WebRTCInfo {
	constructor({ id, channel, initiator}) {
		this.type = 'webrtc'
		this.client = initiator
		this.peer = {
			port: 0,
			host: id,
			topic: channel
		}
	}

	// Can't backoff with WebRTC
	backoff () {
		return false
	}

	// Can't easily deduplicate yet
	deduplicate() {
		return false
	}
}
